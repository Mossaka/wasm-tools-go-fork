package wasi:io;

/// A poll API intended to let users wait for I/O events on multiple handles
/// at once.
interface poll {
    /// A "pollable" handle.
    resource pollable;

    /// Poll for completion on a set of pollables.
    ///
    /// This function takes a list of pollables, which identify I/O sources of
    /// interest, and waits until one or more of the events is ready for I/O.
    ///
    /// The result `list<u32>` contains one or more indices of handles in the
    /// argument list that is ready for I/O.
    ///
    /// If the list contains more elements than can be indexed with a `u32`
    /// value, this function traps.
    ///
    /// A timeout can be implemented by adding a pollable from the
    /// wasi-clocks API to the list.
    ///
    /// This function does not return a `result`; polling in itself does not
    /// do any I/O so it doesn't fail. If any of the I/O sources identified by
    /// the pollables has an error, it is indicated by marking the source as
    /// being reaedy for I/O.
    poll-list: func(in: list<borrow<pollable>>) -> list<u32>;

    /// Poll for completion on a single pollable.
    ///
    /// This function is similar to `poll-list`, but operates on only a single
    /// pollable. When it returns, the handle is ready for I/O.
    poll-one: func(in: borrow<pollable>);
}

/// WASI I/O is an I/O abstraction API which is currently focused on providing
/// stream types.
///
/// In the future, the component model is expected to add built-in stream types;
/// when it does, they are expected to subsume this API.
interface streams {
    use poll.{pollable};

    /// An input bytestream.
    ///
    /// `input-stream`s are *non-blocking* to the extent practical on underlying
    /// platforms. I/O operations always return promptly; if fewer bytes are
    /// promptly available than requested, they return the number of bytes promptly
    /// available, which could even be zero. To wait for data to be available,
    /// use the `subscribe` function to obtain a `pollable` which can be polled
    /// for using `wasi:io/poll`.
    resource input-stream {

        /// Read bytes from a stream, after blocking until at least one byte can
        /// be read. Except for blocking, identical to `read`.
        blocking-read: func(len: u64) -> result<tuple<list<u8>, stream-status>>;

        /// Skip bytes from a stream, after blocking until at least one byte
        /// can be skipped. Except for blocking behavior, identical to `skip`.
        blocking-skip: func(len: u64) -> result<tuple<u64, stream-status>>;

        /// Perform a non-blocking read from the stream.
        ///
        /// This function returns a list of bytes containing the data that was
        /// read, along with a `stream-status` which, indicates whether further
        /// reads are expected to produce data. The returned list will contain up to
        /// `len` bytes; it may return fewer than requested, but not more. An
        /// empty list and `stream-status:open` indicates no more data is
        /// available at this time, and that the pollable given by `subscribe`
        /// will be ready when more data is available.
        ///
        /// Once a stream has reached the end, subsequent calls to `read` or
        /// `skip` will always report `stream-status:ended` rather than producing more
        /// data.
        ///
        /// When the caller gives a `len` of 0, it represents a request to read 0
        /// bytes. This read should  always succeed and return an empty list and
        /// the current `stream-status`.
        ///
        /// The `len` parameter is a `u64`, which could represent a list of u8 which
        /// is not possible to allocate in wasm32, or not desirable to allocate as
        /// as a return value by the callee. The callee may return a list of bytes
        /// less than `len` in size while more bytes are available for reading.
        read: func(len: u64) -> result<tuple<list<u8>, stream-status>>;

        /// Skip bytes from a stream.
        ///
        /// This is similar to the `read` function, but avoids copying the
        /// bytes into the instance.
        ///
        /// Once a stream has reached the end, subsequent calls to read or
        /// `skip` will always report end-of-stream rather than producing more
        /// data.
        ///
        /// This function returns the number of bytes skipped, along with a
        /// `stream-status` indicating whether the end of the stream was
        /// reached. The returned value will be at most `len`; it may be less.
        skip: func(len: u64) -> result<tuple<u64, stream-status>>;

        /// Create a `pollable` which will resolve once either the specified stream
        /// has bytes available to read or the other end of the stream has been
        /// closed.
        /// The created `pollable` is a child resource of the `input-stream`.
        /// Implementations may trap if the `input-stream` is dropped before
        /// all derived `pollable`s created with this function are dropped.
        subscribe: func() -> own<pollable>;
    }

    /// An output bytestream.
    ///
    /// `output-stream`s are *non-blocking* to the extent practical on
    /// underlying platforms. Except where specified otherwise, I/O operations also
    /// always return promptly, after the number of bytes that can be written
    /// promptly, which could even be zero. To wait for the stream to be ready to
    /// accept data, the `subscribe` function to obtain a `pollable` which can be
    /// polled for using `wasi:io/poll`.
    resource output-stream {

        /// Request to flush buffered output, and block until flush completes
        /// and stream is ready for writing again.
        blocking-flush: func() -> result<_, write-error>;

        /// Read from one stream and write to another, with blocking.
        ///
        /// This is similar to `splice`, except that it blocks until at least
        /// one byte can be read.
        blocking-splice: func(src: own<input-stream>, len: u64) -> result<tuple<u64, stream-status>>;

        /// Perform a write of up to 4096 bytes, and then flush the stream. Block
        /// until all of these operations are complete, or an error occurs.
        ///
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write`, and `flush`, and is implemented with the
        /// following pseudo-code:
        ///
        /// ```text
        /// let pollable = this.subscribe();
        /// while !contents.is_empty() {
        /// // Wait for the stream to become writable
        /// poll-one(pollable);
        /// let Ok(n) = this.check-write(); // eliding error handling
        /// let len = min(n, contents.len());
        /// let (chunk, rest) = contents.split_at(len);
        /// this.write(chunk  );            // eliding error handling
        /// contents = rest;
        /// }
        /// this.flush();
        /// // Wait for completion of `flush`
        /// poll-one(pollable);
        /// // Check for any errors that arose during `flush`
        /// let _ = this.check-write();         // eliding error handling
        /// ```
        blocking-write-and-flush: func(contents: list<u8>) -> result<_, write-error>;

        /// Perform a write of up to 4096 zeroes, and then flush the stream.
        /// Block until all of these operations are complete, or an error
        /// occurs.
        ///
        /// This is a convenience wrapper around the use of `check-write`,
        /// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
        /// the following pseudo-code:
        ///
        /// ```text
        /// let pollable = this.subscribe();
        /// while num_zeroes != 0 {
        /// // Wait for the stream to become writable
        /// poll-one(pollable);
        /// let Ok(n) = this.check-write(); // eliding error handling
        /// let len = min(n, num_zeroes);
        /// this.write-zeroes(len);         // eliding error handling
        /// num_zeroes -= len;
        /// }
        /// this.flush();
        /// // Wait for completion of `flush`
        /// poll-one(pollable);
        /// // Check for any errors that arose during `flush`
        /// let _ = this.check-write();         // eliding error handling
        /// ```
        blocking-write-zeroes-and-flush: func(len: u64) -> result<_, write-error>;

        /// Check readiness for writing. This function never blocks.
        ///
        /// Returns the number of bytes permitted for the next call to `write`,
        /// or an error. Calling `write` with more bytes than this function has
        /// permitted will trap.
        ///
        /// When this function returns 0 bytes, the `subscribe` pollable will
        /// become ready when this function will report at least 1 byte, or an
        /// error.
        check-write: func() -> result<u64, write-error>;

        /// Request to flush buffered output. This function never blocks.
        ///
        /// This tells the output-stream that the caller intends any buffered
        /// output to be flushed. the output which is expected to be flushed
        /// is all that has been passed to `write` prior to this call.
        ///
        /// Upon calling this function, the `output-stream` will not accept any
        /// writes (`check-write` will return `ok(0)`) until the flush has
        /// completed. The `subscribe` pollable will become ready when the
        /// flush has completed and the stream can accept more writes.
        flush: func() -> result<_, write-error>;

        /// Forward the entire contents of an input stream to an output stream.
        ///
        /// This function repeatedly reads from the input stream and writes
        /// the data to the output stream, until the end of the input stream
        /// is reached, or an error is encountered.
        ///
        /// Unlike other I/O functions, this function blocks until the end
        /// of the input stream is seen and all the data has been written to
        /// the output stream.
        ///
        /// This function returns the number of bytes transferred, and the status of
        /// the output stream.
        forward: func(src: own<input-stream>) -> result<tuple<u64, stream-status>>;

        /// Read from one stream and write to another.
        ///
        /// This function returns the number of bytes transferred; it may be less
        /// than `len`.
        ///
        /// Unlike other I/O functions, this function blocks until all the data
        /// read from the input stream has been written to the output stream.
        splice: func(src: own<input-stream>, len: u64) -> result<tuple<u64, stream-status>>;

        /// Create a `pollable` which will resolve once the output-stream
        /// is ready for more writing, or an error has occured. When this
        /// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
        /// error.
        ///
        /// If the stream is closed, this pollable is always ready immediately.
        ///
        /// The created `pollable` is a child resource of the `output-stream`.
        /// Implementations may trap if the `output-stream` is dropped before
        /// all derived `pollable`s created with this function are dropped.
        subscribe: func() -> own<pollable>;

        /// Perform a write. This function never blocks.
        ///
        /// Precondition: check-write gave permit of Ok(n) and contents has a
        /// length of less than or equal to n. Otherwise, this function will trap.
        ///
        /// returns Err(closed) without writing if the stream has closed since
        /// the last call to check-write provided a permit.
        write: func(contents: list<u8>) -> result<_, write-error>;

        /// Write zeroes to a stream.
        ///
        /// this should be used precisely like `write` with the exact same
        /// preconditions (must use check-write first), but instead of
        /// passing a list of bytes, you simply pass the number of zero-bytes
        /// that should be written.
        write-zeroes: func(len: u64) -> result<_, write-error>;
    }

    /// Streams provide a sequence of data and then end; once they end, they
    /// no longer provide any further data.
    ///
    /// For example, a stream reading from a file ends when the stream reaches
    /// the end of the file. For another example, a stream reading from a
    /// socket ends when the socket is closed.
    enum stream-status {
        /// The stream is open and may produce further data.
        open,
        /// When reading, this indicates that the stream will not produce
        /// further data.
        /// When writing, this indicates that the stream will no longer be read.
        /// Further writes are still permitted.
        ended
    }

    /// An error for output-stream operations.
    ///
    /// Contrary to input-streams, a closed output-stream is reported using
    /// an error.
    enum write-error {
        /// The last operation (a write or flush) failed before completion.
        last-operation-failed,
        /// The stream is closed: no more input will be accepted by the
        /// stream. A closed output-stream will return this error on all
        /// future operations.
        closed
    }
}

world imports {
    import poll;
    import streams;
}


package wasi:clocks;

/// WASI Monotonic Clock is a clock API intended to let users measure elapsed
/// time.
///
/// It is intended to be portable at least between Unix-family platforms and
/// Windows.
///
/// A monotonic clock is a clock which has an unspecified initial value, and
/// successive reads of the clock will produce non-decreasing values.
///
/// It is intended for measuring elapsed time.
interface monotonic-clock {
    use wasi:io/poll.{pollable};

    /// A timestamp in nanoseconds.
    type instant = u64;

    /// Read the current value of the clock.
    ///
    /// The clock is monotonic, therefore calling this function repeatedly will
    /// produce a sequence of non-decreasing values.
    now: func() -> instant;

    /// Query the resolution of the clock.
    resolution: func() -> instant;

    /// Create a `pollable` which will resolve once the specified time has been
    /// reached.
    subscribe: func(when: instant, absolute: bool) -> own<pollable>;
}

interface timezone {
    use wall-clock.{datetime};

    /// Information useful for displaying the timezone of a specific `datetime`.
    ///
    /// This information may vary within a single `timezone` to reflect daylight
    /// saving time adjustments.
    record timezone-display {
        /// The number of seconds difference between UTC time and the local
        /// time of the timezone.
        ///
        /// The returned value will always be less than 86400 which is the
        /// number of seconds in a day (24*60*60).
        ///
        /// In implementations that do not expose an actual time zone, this
        /// should return 0.
        utc-offset: s32,
        /// The abbreviated name of the timezone to display to a user. The name
        /// `UTC` indicates Coordinated Universal Time. Otherwise, this should
        /// reference local standards for the name of the time zone.
        ///
        /// In implementations that do not expose an actual time zone, this
        /// should be the string `UTC`.
        ///
        /// In time zones that do not have an applicable name, a formatted
        /// representation of the UTC offset may be returned, such as `-04:00`.
        name: string,
        /// Whether daylight saving time is active.
        ///
        /// In implementations that do not expose an actual time zone, this
        /// should return false.
        in-daylight-saving-time: bool
    }

    /// Return information needed to display the given `datetime`. This includes
    /// the UTC offset, the time zone name, and a flag indicating whether
    /// daylight saving time is active.
    ///
    /// If the timezone cannot be determined for the given `datetime`, return a
    /// `timezone-display` for `UTC` with a `utc-offset` of 0 and no daylight
    /// saving time.
    display: func(when: datetime) -> timezone-display;

    /// The same as `display`, but only return the UTC offset.
    utc-offset: func(when: datetime) -> s32;
}

/// WASI Wall Clock is a clock API intended to let users query the current
/// time. The name "wall" makes an analogy to a "clock on the wall", which
/// is not necessarily monotonic as it may be reset.
///
/// It is intended to be portable at least between Unix-family platforms and
/// Windows.
///
/// A wall clock is a clock which measures the date and time according to
/// some external reference.
///
/// External references may be reset, so this clock is not necessarily
/// monotonic, making it unsuitable for measuring elapsed time.
///
/// It is intended for reporting the current date and time for humans.
interface wall-clock {
    /// A time and date in seconds plus nanoseconds.
    record datetime {
        seconds: u64,
        nanoseconds: u32
    }

    /// Read the current value of the clock.
    ///
    /// This clock is not monotonic, therefore calling this function repeatedly
    /// will not necessarily produce a sequence of non-decreasing values.
    ///
    /// The returned timestamps represent the number of seconds since
    /// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
    /// also known as [Unix Time].
    ///
    /// The nanoseconds field of the output is always less than 1000000000.
    ///
    /// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
    /// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
    now: func() -> datetime;

    /// Query the resolution of the clock.
    ///
    /// The nanoseconds field of the output is always less than 1000000000.
    resolution: func() -> datetime;
}

world imports {
    import monotonic-clock;
    import wasi:io/poll;
    import timezone;
    import wall-clock;
}
